'''
Application 4 - Applications to genomics and beyond
'''

import math
import random
import urllib2
import matplotlib.pyplot as plt
import project4


# URLs for data files
PAM50_URL = "http://storage.googleapis.com/codeskulptor-alg/alg_PAM50.txt"
HUMAN_EYELESS_URL = "http://storage.googleapis.com/codeskulptor-alg/alg_HumanEyelessProtein.txt"
FRUITFLY_EYELESS_URL = "http://storage.googleapis.com/codeskulptor-alg/alg_FruitflyEyelessProtein.txt"
CONSENSUS_PAX_URL = "http://storage.googleapis.com/codeskulptor-alg/alg_ConsensusPAXDomain.txt"
WORD_LIST_URL = "http://storage.googleapis.com/codeskulptor-assets/assets_scrabble_words3.txt"


def read_scoring_matrix(filename):
   '''
   Read a scoring matrix from the file named filename.

   Argument:
   filename -- name of file containing a scoring matrix

   Returns:
   A dictionary of dictionaries mapping X and Y characters to scores
   '''
   scoring_matrix = {}

   scoring_file = urllib2.urlopen(filename)
   scoring_file = scoring_file.read()
   scoring_file_list = scoring_file.splitlines()

   keys = scoring_file_list[0].split()
   for line in scoring_file_list[1:]:
      vals = line.split()
      scoring_matrix[vals[0]] = {}
      i = 1
      for key in keys:
         scoring_matrix[vals[0]].update({key: int(vals[i])})
         i += 1
   return scoring_matrix


def read_protein(filename):
   """
   Read a protein sequence from the file named filename.

   Arguments:
   filename -- name of file containing a protein sequence

   Returns:
   A string representing the protein
   """
   protein_file = urllib2.urlopen(filename)
   protein_seq = protein_file.read()
   protein_seq = protein_seq.rstrip()
   return protein_seq


def read_words(filename):
   """
   Load word list from the file named filename.

   Returns a list of strings.
   """
   # load assets
   word_file = urllib2.urlopen(filename)

   # read in files as string
   words = word_file.read()

   # template lines and solution lines list of line string
   word_list = words.splitlines()
   print "Loaded a dictionary with", len(word_list), "words"
   return word_list


def remove_dashes(seq):
   '''
   Remove all dashes from the sequence and return seq without dashes
   '''
   no_dash_seq = ''
   for char in seq.split('-'):
      if char:
         no_dash_seq += char
   return no_dash_seq


def compute_aggrement(alignment):
   '''
   Given an alignment of two sequences,
   compute the percentage of elements in these two sequences that agree
   '''
   xseq = alignment[1]
   yseq = alignment[2]

   similar = 0
   for i in range(len(xseq)):
      if xseq[i] == yseq[i]:
         similar += 1
      i += 1


   return (similar / float(len(xseq))) * 100


def generate_null_distribution(seq_x, seq_y, scoring_matrix, num_trials):
   '''
   1) Generate a random permutation 'rand_y' of the sequence seq_y
   2) Compute the maximum value 'score' for the local alignment of seq_x and rand_y using the score matrix 'scoring_matrix'

   Return local alignment score
   '''
   temp = list(seq_y)
   random.shuffle(temp)
   seq_y = ''.join(temp)

   local_alignment_matrix = project4.compute_alignment_matrix(seq_x, seq_y, scoring_matrix, False)
   local_alignment = project4.compute_local_alignment(seq_x, seq_y, scoring_matrix, local_alignment_matrix)
   return local_alignment[0]


def get_unnormalized_distribution(seq_x, seq_y, scoring_matrix, num_trials):
   '''
   Return a dictionary 'scoring_distribution' that represents an un-normalized distribution
   generated by 'generate_null_distribution' 'num_trials' times
   '''
   scoring_distribution = {}

   for i in range(num_trials):
      score = generate_null_distribution(seq_x, seq_y, scoring_matrix, num_trials)
      if score in scoring_distribution:
         scoring_distribution[score] += 1
      else:
         scoring_distribution[score] = 1

   return scoring_distribution

def plot_distribution(score):
   '''
   Create a bar plot of the normalized version of the distribution
   returned by 'get_unnormalized_distribution'.
   The horizontal axis should be the score
   The vertical axis should be the fraction of total trials corresponding to each score
   '''
   xvals = score.keys()
   total_trials = sum(score.values())
   yvals = map(lambda x: x / float(total_trials), score.values())

   # this is a temp fix since we are using simpleplot instead of matplotlib
   # plot can be viewed here - http://www.codeskulptor.org/#user38_LduOh38Dpv_1.py
   normalized_score = {}
   for val1, val2 in zip(xvals, yvals):
      normalized_score[val1] = val2


   print 'normalized {}'.format(normalized_score)

   #width = 0.35 # width of the bars
   #plt.bar(xvals, yvals, width, color='r')
   #plt.plot(xvals, yvals, '-b', label='linear')
   #plt.xlabel('Scores')
   #plt.ylabel('Normalized trials')
   #plt.title('Normalized Distribution of local alignment scores for HumanEyelessProtein and FruitflyEyelessProtein')
   #plt.show()

def calulate_statistical_data(data):
   '''
   Calculate the mean, standard deviation and z-score for the
   normalized version of the distribution
   returned by 'get_unnormalized_distribution'.
   '''

   n = sum(data.values()) # number of trials

   # calculate mean
   # eg. data = {5: 3, 7: 4, 8: 4, 9: 5, 10: 7}
   # mean = (5*3 + 7*4 + 8*4 + 9*5 + 10*7)/ 23
   mean = 0
   for k, v in data.iteritems():
      mean += k * v

   mean = mean/ float(n)

   # calculate standard deviation
   sum_squares = 0
   for k, v in data.iteritems():
      sum_squares += ((k - mean) ** 2) * v

   sd = math.sqrt(sum_squares / float(n))

   # calculate z-score for local alignment score from Question 1
   zscore = (875 - mean) / float(sd)

   print 'Mean is {} SD is {}'.format(mean, sd)
   print 'Z-score for a local alignment score of 875 is {}'.format(zscore)


def  calculate_edit_distance(xseq, yseq):
   '''
   Return the edit distance of xseq and yseq
   http://en.wikipedia.org/wiki/Edit_distance
   '''
   alphabet = set(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l',
                   'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x',
                   'y', 'z', '-'])

   scoring_matrix = project4.build_scoring_matrix(alphabet, 2, 1, 0)
   global_alignment_matrix = project4.compute_alignment_matrix(xseq, yseq, scoring_matrix, True)
   global_alignment = project4.compute_global_alignment(xseq, yseq, scoring_matrix,global_alignment_matrix)

   edit_distance = len(xseq) + len(yseq) - global_alignment[0]

   #print global_alignment
   # print  edit_distance
   return edit_distance

def check_spelling(checked_word, dist, word_list):
   '''
   Iterates through 'word_list' and returns the set of all words that are within
   edit distance 'dist' of the string 'checked_word'
   '''
   final_set = set()
   for word in word_list:
      edit_dist = calculate_edit_distance(checked_word, word)
      if edit_dist <= dist:
         final_set.add(word)

   return final_set


def main():
   scoring_matrix = read_scoring_matrix(PAM50_URL)

   # Question 1
   #xseq = read_protein(HUMAN_EYELESS_URL)
   #yseq = read_protein(FRUITFLY_EYELESS_URL)

   # compute local alignment
   #local_alignment_matrix = project4.compute_alignment_matrix(xseq, yseq, scoring_matrix, False)
   #local_alignment = project4.compute_local_alignment(xseq, yseq, scoring_matrix, local_alignment_matrix)
   #print local_alignment

   # Question 2
   #xseq_no_dash = remove_dashes(local_alignment[1])
   #yseq_no_dash = remove_dashes(local_alignment[2])
   #consensus_seq = read_protein(CONSENSUS_PAX_URL)

   # global alignment
   #global_alignment_matrix_1 = project4.compute_alignment_matrix(xseq_no_dash, consensus_seq, scoring_matrix, True)
   #global_alignment_1 = project4.compute_global_alignment(xseq_no_dash, consensus_seq, scoring_matrix, global_alignment_matrix_1)

   #global_alignment_matrix_2 = project4.compute_alignment_matrix(yseq_no_dash, consensus_seq, scoring_matrix, True)
   #global_alignment_2 = project4.compute_global_alignment(yseq_no_dash, consensus_seq, scoring_matrix, global_alignment_matrix_2)

   #human_consensus_agree =  compute_aggrement(global_alignment_1)
   #fruitfly_consensus_agree =  compute_aggrement(global_alignment_2)

   #print 'Agreement of global alignment of local human vs. consensus PAX is {}'.format(human_consensus_agree)
   #print 'Agreement of global alignment of local fruitfly vs. consensus PAX is {}'.format(fruitfly_consensus_agree)

   # Question 4
   #score = get_unnormalized_distribution(xseq, yseq, scoring_matrix, 1000)
   #plot_distribution(score)

   # Question 5
   #calulate_statistical_data(score)

   #********************************************************#
   # Spelling correction #
   #********************************************************#
   # Question 8

   list_of_words = read_words(WORD_LIST_URL)
   #words = check_spelling('humble', 1, list_of_words)
   words = check_spelling('firefly', 2, list_of_words)
   print words

if __name__ == '__main__':
   main()
